{"version":3,"sources":["angular-markdown-text-header.js","angular-markdown-text.js","directive.js","service.js","angular-markdown-text-footer.js"],"names":[],"mappings":"AAAA;GACA;GACA;GACA;AACA;AACA;;ACLA;;AAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;IACA;EACA;AACA;ACbA,oBAAA,QAAA,GAAA,0DAAA;;EAEA;IACA;EACA;;EAEA;IACA;IACA;IACA;;MAEA;;MAEA;MACA;MACA;;MAEA;MACA;;MAEA;QACA;UACA;QACA;QACA;;UAEA;UACA;YACA;;cAEA;;cAEA;;gBAEA;;gBAEA;;gBAEA;kBACA;;oBAEA;;oBAEA;sBACA;sBACA;wBACA;sBACA;oBACA;kBACA;;oBAEA;;oBAEA;sBACA;oBACA;kBACA;gBACA;;kBAEA;;kBAEA;gBACA;;cAEA;;YAEA;cACA;cACA;gBACA;gBACA;kBACA;gBACA;cACA;YACA;cACA;cACA;;cAEA;gBACA;cACA;;YAEA;UACA;QACA;MACA;IACA;EACA;AACA,CAAA,CAAA;ACxFA,kBAAA,QAAA,GAAA,gCAAA;;EAEA;;EAEA;IACA;EACA;;EAEA;IACA;IACA;EACA;;EAEA;;IAEA;;IAEA;MACA;IACA;;IAEA;MACA;IACA;;IAEA;;IAEA;;MAEA;QACA;MACA;;MAEA;QACA;MACA;QACA;QACA;MACA;;IAEA;;IAEA;EACA;;EAEA;IACA;MACA;MACA;MACA;EACA;;EAEA;;IAEA;;MAEA;;MAEA;;MAEA;;MAEA;MACA;;QAEA;;QAEA;QACA;QACA;MACA;IACA;;IAEA;EACA;;EAEA;IACA;IACA;IACA;IACA;EACA;;AAEA,CAAA,CAAA;ACnFA","file":"angular-markdown-text.js","sourcesContent":["/*!\n   angular-markdown-text v0.0.1\n   (c) 2014 (null) McNull https://github.com/McNull/angular-markdown-text\n   License: MIT\n*/\n(function(angular,Showdown) {\n","var markdown = angular.module('markdown', []);\n\nmarkdown.constant('markdownConfig', {\n  // Outline static markup\n  outline: true,\n  // Escape html\n  escapeHtml: false,\n  // Sanitize html,\n  sanitize: true,\n  // Showdown options\n  showdown: {\n    extensions: []\n  }\n});","markdown.directive('markdown', function (markdown, markdownConfig, $http, $templateCache) {\n\n  function parseBoolAttr($attrs, name, defaultValue) {\n    return $attrs[name] ? $attrs[name] == 'true' : defaultValue;\n  }\n\n  return {\n    restrict: 'AE',\n    terminal: true,\n    compile: function (tElement, tAttrs) {\n\n      var options = angular.copy(markdownConfig);\n\n      options.escapeHtml = parseBoolAttr(tAttrs, 'markdownEscapeHtml', options.escapeHtml);\n      options.outline = parseBoolAttr(tAttrs, 'markdownOutline', options.outline);\n      options.sanitize = parseBoolAttr(tAttrs, 'markdownSanitize', options.sanitize);\n\n      var modelExpr = tAttrs.markdown || tAttrs.markdownModel;\n      var srcExpr = tAttrs.markdownSrc;\n\n      return {\n        pre: function ($scope, $element) {\n          $element.data('markdown', true);\n        },\n        post: function ($scope, $element) {\n\n          // Only link if we're not in markdown scope.\n          if (!$element.parent().inheritedData('markdown')) {\n            if (srcExpr) {\n\n              var counter = 0;\n\n              $scope.$watch(srcExpr, function (value) {\n\n                // Keep track of outstanding requests\n\n                var id = ++counter;\n\n                if (value) {\n                  $http.get(value, { cache: $templateCache }).success(function (response) {\n\n                    // Only update if this is the latest response.\n\n                    if (id == counter) {\n                      var result = response ? markdown.makeHtml(response, options) : '';\n                      if (result != undefined) {\n                        $element.html(result);\n                      }\n                    }\n                  }).error(function () {\n\n                    // Only update if this is the latest response.\n\n                    if (id == counter) {\n                      $element.html('');\n                    }\n                  });\n                } else {\n\n                  // No expression, no html\n\n                  $element.html('');\n                }\n\n              });\n\n            } else if (modelExpr) {\n              // Watch and convert the expression output\n              $scope.$watch(modelExpr, function (value) {\n                var result = value ? markdown.makeHtml(value, options) : '';\n                if (result != undefined) {\n                  $element.html(result);\n                }\n              });\n            } else {\n              // Convert the static innerHtml\n              var result = markdown.makeHtml($element.html(), options);\n\n              if (result != undefined) {\n                $element.html(result);\n              }\n\n            }\n          }\n        }\n      }\n    }\n  };\n});","markdown.factory('markdown', function (markdownConfig, $injector) {\n\n  var _converter, $sanitize;\n\n  if ($injector.has('$sanitize')) {\n    $sanitize = $injector.get('$sanitize');\n  }\n\n  function _getConverter() {\n    _converter = _converter || new Showdown.converter(markdownConfig.showdown);\n    return _converter;\n  }\n\n  function makeHtml(text, options) {\n\n    options = options || markdownConfig;\n\n    if(options.outline) {\n      text = outline(text);\n    }\n\n    if(options.escapeHtml) {\n      text = escapeHtml(text);\n    }\n\n    var html = _getConverter().makeHtml(text);\n\n    if (options.sanitize) {\n\n      if (!$sanitize) {\n        throw new Error('Missing dependency angular-sanitize.');\n      }\n\n      try {\n        html = $sanitize(html);\n      } catch(ex) {\n        console.log(ex);\n        html = undefined;\n      }\n\n    }\n\n    return html;\n  }\n\n  function escapeHtml(s) {\n    return s.replace(/&/g, '&amp;')\n      .replace(/\"/g, '&quot;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n  }\n\n  function outline(text) {\n\n    if (text) {\n\n      // trim leading empty lines\n\n      text = text.replace(/^\\s*\\n/, '');\n\n      // grab the first ident on the first line\n\n      var m = text.match(/^[ \\t]+/);\n      if (m && m.length) {\n\n        // build a pattern to strip out the located ident from all lines\n\n        var p = '^[ \\t]{' + m[0].length + '}';\n        var r = new RegExp(p, 'gm');\n        text = text.replace(r, '');\n      }\n    }\n\n    return text;\n  }\n\n  return {\n    _converter: _getConverter,\n    makeHtml: makeHtml,\n    outline: outline,\n    escapeHtml: escapeHtml\n  };\n\n});","})(angular,Showdown);"],"sourceRoot":"../src/angular-markdown-text"}